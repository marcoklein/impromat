# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ElementTag {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!
  name: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserFavoriteElement {
  createdAt: DateTime!
  updatedAt: DateTime!
  element: Element!
}

type WorkshopElement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!
  note: String
  basedOn: Element!
  section: WorkshopSection!
}

type WorkshopSection {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!
  name: String
  color: String
  isCollapsed: Boolean!
  elements: [WorkshopElement!]!
  workshop: Workshop!
  orderIndex: Float!
}

type Workshop {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!
  name: String!
  description: String
  sections: [WorkshopSection!]!
  owner: User!

  """If true, the client is authorized to edit the workshop."""
  canEdit: Boolean
  isPublic: Boolean!

  """
  True, if liked by the logged in user. Undefined, if there is no user logged in.
  """
  isLiked: Boolean

  """
  Convenience field to determine if the owner of the workshop is the logged in user.
  """
  isOwnerMe: Boolean
}

type UserLikedWorkshop {
  createdAt: DateTime!
  updatedAt: DateTime!
  workshop: Workshop!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!

  """All workshops that this user has access to."""
  workshops(input: UserWorkshopsFilterInput! = {liked: true, owned: true}): [Workshop!]!

  """Elements owned by this user."""
  elements: [Element!]!
  favoriteElements: [UserFavoriteElement!]!
  likedWorkshops: [UserLikedWorkshop!]!

  """Public display name of the user."""
  name: String
}

"""Filter workshops of user."""
input UserWorkshopsFilterInput {
  liked: Boolean! = true

  """Filter for workshops that are owned by the user."""
  owned: Boolean! = true
}

type Element {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int!
  deleted: Boolean!
  name: String!
  markdown: String

  """
  Shortened markdown text for preview purposes to avoid loading the whole content in a request.
  """
  markdownShort: String
  tags: [ElementTag!]!
  usedBy: [WorkshopElement!]!
  languageCode: String
  sourceUrl: String
  sourceName: String
  sourceBaseUrl: String
  licenseName: String
  licenseUrl: String
  owner: User

  """
  Convenience field to determine if the owner of the element is the logged in user.
  """
  isOwnerMe: Boolean
  visibility: ElementVisibility!

  """Set if the element is called from a user context."""
  isFavorite: Boolean
}

enum ElementVisibility {
  """Element is only visible to its owning user."""
  PRIVATE

  """Element is publicly shared with the whole community."""
  PUBLIC
}

type ElementSearchMatch {
  """Key of field where searched text was found."""
  key: String
  indices: [[Int!]!]!

  """
  If the matching field is an array this field points to the index of the matching element in the source array.
  """
  refIndex: Int
  value: String!
}

type ElementSearchResult {
  element: Element!
  score: Float!
  matches: [ElementSearchMatch!]!
}

type Query {
  googleAuthUrl: String!
  searchElements(
    input: ElementSearchInput!

    """Helper field to pass skip argument into input field."""
    skip: Int

    """Helper field to pass take argument into input field."""
    take: Int
  ): [ElementSearchResult!]!
  workshop(id: ID!): Workshop!
  workshops: [Workshop!]!
  workshopElement(id: ID!): WorkshopElement!
  element(id: ID!): Element
  elements(input: ElementsQueryInput, skip: Float, take: Float): [Element!]

  """Get information about the current user."""
  me: User!
}

input ElementSearchInput {
  text: String
  take: Int! = 20
  skip: Int! = 0
}

input ElementsQueryInput {
  filter: ElementsFilterInput
  orderBy: ElementsOrderByInput
  take: Int! = 20
  skip: Int! = 0
}

input ElementsFilterInput {
  """Include all elements of the currently active user."""
  isOwnerMe: Boolean

  """
  Include all elements that are publicaly available to the logged-in user.
  """
  isPublic: Boolean
}

input ElementsOrderByInput {
  notImplemented: Boolean!
}

type Mutation {
  logout: Boolean!

  """Change the favorite state for element of the logged in user."""
  updateUserFavoriteElement(input: UpdateUserFavoriteElementInput!): Element

  """Change the liked state for workshop of the logged in user."""
  updateUserLikedWorkshop(input: UpdateUserLikedWorkshopInput!): Workshop
  createWorkshop(input: CreateWorkshopInput!): Workshop!
  updateWorkshop(input: UpdateWorkshopInput!): Workshop!
  deleteWorkshop(id: ID!): Workshop
  updateWorkshopItemOrder(input: UpdateWorkshopItemOrder!): Workshop!
  createElement(input: CreateElementInput!): Element!
  updateElement(input: UpdateElementInput!): Element!
  updateUser(input: UpdateUserInput!): User!
}

input UpdateUserFavoriteElementInput {
  elementId: ID!
  isFavorite: Boolean!
}

input UpdateUserLikedWorkshopInput {
  workshopId: ID!
  isLiked: Boolean!
}

input CreateWorkshopInput {
  name: String!
  description: String
  sections: WorkshopSectionListCreateInput
  isPublic: Boolean
}

input WorkshopSectionListCreateInput {
  create: [CreateWorkshopSectionInput!]
}

input CreateWorkshopSectionInput {
  name: String!
  orderIndex: Float
  isCollapsed: Boolean
}

input UpdateWorkshopInput {
  name: String
  description: String
  sections: WorkshopSectionListInput
  isPublic: Boolean
  id: ID!
}

input WorkshopSectionListInput {
  create: [CreateWorkshopSectionInput!]
  update: [UpdateWorkshopSectionInput!]
  delete: [DeleteWorkshopSectionInput!]
}

input UpdateWorkshopSectionInput {
  name: String
  orderIndex: Float
  isCollapsed: Boolean
  id: ID!
  elements: WorkshopElementListInput
}

input WorkshopElementListInput {
  create: [CreateWorkshopElementInput!]
  update: [UpdateWorkshopElementInput!]
  delete: [DeleteWorkshopElementInput!]
}

input CreateWorkshopElementInput {
  note: String
  basedOn: BasedOnElementConnectInput!
  orderIndex: Float
}

input BasedOnElementConnectInput {
  connect: IdInput!
}

input IdInput {
  id: ID!
}

input UpdateWorkshopElementInput {
  note: String
  basedOn: BasedOnElementConnectInput
  orderIndex: Float
  id: ID!
}

input DeleteWorkshopElementInput {
  id: ID!
}

input DeleteWorkshopSectionInput {
  id: ID!
}

"""
Moves a workshop item (section or element) within a workshop considering collapsed sections.
"""
input UpdateWorkshopItemOrder {
  workshopId: ID!

  """From position."""
  fromPosition: Int!

  """To position."""
  toPosition: Int!
}

input CreateElementInput {
  name: String!
  visibility: ElementVisibility! = PRIVATE
  markdown: String
  languageCode: String!
  orderIndex: Int
}

input UpdateElementInput {
  name: String
  visibility: ElementVisibility = PRIVATE
  markdown: String
  languageCode: String
  orderIndex: Int
  id: ID!
}

input UpdateUserInput {
  id: ID!
  name: String!
}